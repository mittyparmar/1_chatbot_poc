/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const pure = typeof process !== 'undefined' ? process.env['REMOTES'] || {} : {};
const remoteVars = pure;
const extractUrlAndGlobal = (urlAndGlobal) => {
    const index = urlAndGlobal.indexOf('@');
    if (index <= 0 || index === urlAndGlobal.length - 1) {
        throw new Error(`Invalid request "${urlAndGlobal}"`);
    }
    return [urlAndGlobal.substring(index + 1), urlAndGlobal.substring(0, index)];
};
const loadScript = (keyOrRuntimeRemoteItem) => {
    const runtimeRemotes = getRuntimeRemotes$1();
    // 1) Load remote container if needed
    let asyncContainer;
    const reference = typeof keyOrRuntimeRemoteItem === 'string'
        ? runtimeRemotes[keyOrRuntimeRemoteItem]
        : keyOrRuntimeRemoteItem;
    if (reference.asyncContainer) {
        asyncContainer =
            typeof reference.asyncContainer.then === 'function'
                ? reference.asyncContainer
                : // @ts-ignore
                    reference.asyncContainer();
    }
    else {
        // This casting is just to satisfy typescript,
        // In reality remoteGlobal will always be a string;
        const remoteGlobal = reference.global;
        // Check if theres an override for container key if not use remote global
        const containerKey = reference.uniqueKey
            ? reference.uniqueKey
            : remoteGlobal;
        const __webpack_error__ = new Error();
        // @ts-ignore
        const globalScope = 
        // @ts-ignore
        typeof window !== 'undefined' ? window : globalThis.__remote_scope__;
        if (typeof window === 'undefined') {
            //@ts-ignore
            globalScope['_config'][containerKey] = reference.url;
        }
        else {
            // to match promise template system, can be removed once promise template is gone
            //@ts-ignore
            if (!globalScope['remoteLoading']) {
                //@ts-ignore
                globalScope['remoteLoading'] = {};
            }
            //@ts-ignore
            if (globalScope['remoteLoading'][containerKey]) {
                //@ts-ignore
                return globalScope['remoteLoading'][containerKey];
            }
        }
        // @ts-ignore
        asyncContainer = new Promise(function (resolve, reject) {
            function resolveRemoteGlobal() {
                //@ts-ignore
                const asyncContainer = globalScope[remoteGlobal];
                return resolve(asyncContainer);
            }
            //@ts-ignore
            if (typeof globalScope[remoteGlobal] !== 'undefined') {
                return resolveRemoteGlobal();
            }
            __webpack_require__.l(reference.url, function (event) {
                //@ts-ignore
                if (typeof globalScope[remoteGlobal] !== 'undefined') {
                    return resolveRemoteGlobal();
                }
                const errorType = event && (event.type === 'load' ? 'missing' : event.type);
                const realSrc = event && event.target && event.target.src;
                __webpack_error__.message =
                    'Loading script failed.\n(' +
                        errorType +
                        ': ' +
                        realSrc +
                        ' or global var ' +
                        remoteGlobal +
                        ')';
                __webpack_error__.name = 'ScriptExternalLoadError';
                __webpack_error__.type = errorType;
                __webpack_error__.request = realSrc;
                reject(__webpack_error__);
            }, containerKey);
        }).catch(function (err) {
            console.error('container is offline, returning fake remote');
            console.error(err);
            return {
                fake: true,
                // @ts-ignore
                get: (arg) => {
                    console.warn('faking', arg, 'module on, its offline');
                    return Promise.resolve(() => {
                        return {
                            __esModule: true,
                            default: () => {
                                return null;
                            },
                        };
                    });
                },
                //eslint-disable-next-line
                init: () => { },
            };
        });
        if (typeof window !== 'undefined') {
            //@ts-ignore
            globalScope['remoteLoading'][containerKey] = asyncContainer;
        }
    }
    return asyncContainer;
};
const getRuntimeRemotes$1 = () => {
    return Object.entries(remoteVars).reduce((acc, [key, value]) => {
        if (typeof value === 'object' && typeof value.then === 'function') {
            acc[key] = { asyncContainer: value };
        }
        else if (typeof value === 'function') {
            acc[key] = { asyncContainer: Promise.resolve(value()) };
        }
        else if (typeof value === 'string') {
            if (value.startsWith('internal ')) {
                const [request, query] = value.replace('internal ', '').split('?');
                if (query) {
                    const remoteSyntax = new URLSearchParams(query).get('remote');
                    if (remoteSyntax) {
                        const [url, global] = extractUrlAndGlobal(remoteSyntax);
                        acc[key] = { global, url };
                    }
                }
            }
            else {
                const [url, global] = extractUrlAndGlobal(value);
                acc[key] = { global, url };
            }
        }
        else {
            console.warn('remotes process', process.env['REMOTES']);
            throw new Error(`[mf] Invalid value received for runtime_remote "${key}"`);
        }
        return acc;
    }, {});
};

/* eslint-disable @typescript-eslint/ban-ts-comment */
const createContainerSharingScope = (asyncContainer) => {
    // @ts-ignore
    return asyncContainer
        .then(function (container) {
        if (!__webpack_share_scopes__['default']) {
            // not always a promise, so we wrap it in a resolve
            return Promise.resolve(__webpack_init_sharing__('default')).then(function () {
                return container;
            });
        }
        else {
            return container;
        }
    })
        .then(function (container) {
        try {
            // WARNING: here might be a potential BUG.
            //   `container.init` does not return a Promise, and here we do not call `then` on it.
            // But according to [docs](https://webpack.js.org/concepts/module-federation/#dynamic-remote-containers)
            //   it must be async.
            // The problem may be in Proxy in NextFederationPlugin.js.
            //   or maybe a bug in the webpack itself - instead of returning rejected promise it just throws an error.
            // But now everything works properly and we keep this code as is.
            container.init(__webpack_share_scopes__['default']);
        }
        catch (e) {
            // maybe container already initialized so nothing to throw
        }
        return container;
    });
};
/**
 * Return initialized remote container by remote's key or its runtime remote item data.
 *
 * `runtimeRemoteItem` might be
 *    { global, url } - values obtained from webpack remotes option `global@url`
 * or
 *    { asyncContainer } - async container is a promise that resolves to the remote container
 */
const injectScript = (keyOrRuntimeRemoteItem) => __awaiter(void 0, void 0, void 0, function* () {
    const asyncContainer = loadScript(keyOrRuntimeRemoteItem);
    return createContainerSharingScope(asyncContainer);
});
/**
 * Creates runtime variables from the provided remotes.
 * If the value of a remote starts with 'promise ' or 'external ', it is transformed into a function that returns the promise call.
 * Otherwise, the value is stringified.
 * @param {Remotes} remotes - The remotes to create runtime variables from.
 * @returns {Record<string, string>} - The created runtime variables.
 */
const createRuntimeVariables = (remotes) => {
    if (!remotes) {
        return {};
    }
    return Object.entries(remotes).reduce((acc, [key, value]) => {
        if (value.startsWith('promise ') || value.startsWith('external ')) {
            const promiseCall = value.split(' ')[1];
            acc[key] = `function() {
        return ${promiseCall}
      }`;
        }
        else {
            acc[key] = JSON.stringify(value);
        }
        return acc;
    }, {});
};
/**
 * Returns initialized webpack RemoteContainer.
 * If its' script does not loaded - then load & init it firstly.
 */
const getContainer = (remoteContainer) => __awaiter(void 0, void 0, void 0, function* () {
    if (!remoteContainer) {
        throw Error(`Remote container options is empty`);
    }
    const containerScope = typeof window !== 'undefined'
        ? window
        : globalThis.__remote_scope__;
    let containerKey;
    if (typeof remoteContainer === 'string') {
        containerKey = remoteContainer;
    }
    else {
        containerKey = remoteContainer.uniqueKey;
        if (!containerScope[containerKey]) {
            const container = yield injectScript({
                global: remoteContainer.global,
                url: remoteContainer.url,
            });
            if (!container) {
                throw Error(`Remote container ${remoteContainer.url} is empty`);
            }
        }
    }
    return containerScope[containerKey];
});
/**
 * Return remote module from container.
 * If you provide `exportName` it automatically return exact property value from module.
 *
 * @example
 *   remote.getModule('./pages/index', 'default')
 */
const getModule = (_a) => __awaiter(void 0, [_a], void 0, function* ({ remoteContainer, modulePath, exportName, }) {
    const container = yield getContainer(remoteContainer);
    try {
        const modFactory = yield (container === null || container === void 0 ? void 0 : container.get(modulePath));
        if (!modFactory) {
            return undefined;
        }
        const mod = modFactory();
        if (exportName) {
            return mod && typeof mod === 'object' ? mod[exportName] : undefined;
        }
        else {
            return mod;
        }
    }
    catch (error) {
        console.error(error);
        return undefined;
    }
});

const isObjectEmpty = (obj) => {
    for (const x in obj) {
        return false;
    }
    return true;
};

/**
 * Constant for remote entry file
 * @constant {string}
 */
const REMOTE_ENTRY_FILE = 'remoteEntry.js';
/**
 * Function to load remote
 * @function
 * @param {ImportRemoteOptions['url']} url - The url of the remote module
 * @param {ImportRemoteOptions['scope']} scope - The scope of the remote module
 * @param {ImportRemoteOptions['bustRemoteEntryCache']} bustRemoteEntryCache - Flag to bust the remote entry cache
 * @returns {Promise<void>} A promise that resolves when the remote is loaded
 */
const loadRemote = (url, scope, bustRemoteEntryCache) => new Promise((resolve, reject) => {
    const timestamp = bustRemoteEntryCache ? `?t=${new Date().getTime()}` : '';
    const webpackRequire = __webpack_require__;
    webpackRequire.l(`${url}${timestamp}`, (event) => {
        var _a;
        if ((event === null || event === void 0 ? void 0 : event.type) === 'load') {
            // Script loaded successfully:
            return resolve();
        }
        const realSrc = (_a = event === null || event === void 0 ? void 0 : event.target) === null || _a === void 0 ? void 0 : _a.src;
        const error = new Error();
        error.message = 'Loading script failed.\n(missing: ' + realSrc + ')';
        error.name = 'ScriptExternalLoadError';
        reject(error);
    }, scope);
});
const loadEsmRemote = (url, scope) => __awaiter(void 0, void 0, void 0, function* () {
    const module = yield import(/* webpackIgnore: true */ url);
    if (!module) {
        throw new Error(`Unable to load requested remote from ${url} with scope ${scope}`);
    }
    window[scope] = Object.assign(Object.assign({}, module), { __initializing: false, __initialized: false });
});
/**
 * Function to initialize sharing
 * @async
 * @function
 */
const initSharing = () => __awaiter(void 0, void 0, void 0, function* () {
    const webpackShareScopes = __webpack_share_scopes__;
    if (!(webpackShareScopes === null || webpackShareScopes === void 0 ? void 0 : webpackShareScopes.default)) {
        yield __webpack_init_sharing__('default');
    }
});
/**
 * Function to initialize container
 * @async
 * @function
 * @param {WebpackRemoteContainer} containerScope - The container scope
 */
const initContainer = (containerScope) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const webpackShareScopes = __webpack_share_scopes__;
        if (!containerScope.__initialized && !containerScope.__initializing) {
            containerScope.__initializing = true;
            yield containerScope.init(webpackShareScopes.default);
            containerScope.__initialized = true;
            delete containerScope.__initializing;
        }
    }
    catch (error) {
        console.error(error);
    }
});
/**
 * Function to import remote
 * @async
 * @function
 * @param {ImportRemoteOptions} options - The options for importing the remote
 * @returns {Promise<T>} A promise that resolves with the imported module
 */
const importRemote = (_a) => __awaiter(void 0, [_a], void 0, function* ({ url, scope, module, remoteEntryFileName = REMOTE_ENTRY_FILE, bustRemoteEntryCache = true, esm = false, }) {
    const remoteScope = scope;
    if (!window[remoteScope]) {
        let remoteUrl = '';
        if (typeof url === 'string') {
            remoteUrl = url;
        }
        else {
            remoteUrl = yield url();
        }
        const remoteUrlWithEntryFile = `${remoteUrl}/${remoteEntryFileName}`;
        const asyncContainer = !esm
            ? loadRemote(remoteUrlWithEntryFile, scope, bustRemoteEntryCache)
            : loadEsmRemote(remoteUrlWithEntryFile, scope);
        // Load the remote and initialize the share scope if it's empty
        yield Promise.all([asyncContainer, initSharing()]);
        if (!window[remoteScope]) {
            throw new Error(`Remote loaded successfully but ${scope} could not be found! Verify that the name is correct in the Webpack configuration!`);
        }
        // Initialize the container to get shared modules and get the module factory:
        const [, moduleFactory] = yield Promise.all([
            initContainer(window[remoteScope]),
            window[remoteScope].get(module === '.' || module.startsWith('./') ? module : `./${module}`),
        ]);
        return moduleFactory();
    }
    else {
        const moduleFactory = yield window[remoteScope].get(module === '.' || module.startsWith('./') ? module : `./${module}`);
        return moduleFactory();
    }
});

class Logger {
    static getLogger() {
        return this.loggerInstance;
    }
    static setLogger(logger) {
        this.loggerInstance = logger || console;
        return logger;
    }
}
Logger.loggerInstance = console;

const getRuntimeRemotes = () => {
    try {
        return Object.entries(remoteVars).reduce(function (acc, item) {
            const [key, value] = item;
            // if its an object with a thenable (eagerly executing function)
            if (typeof value === 'object' && typeof value.then === 'function') {
                acc[key] = { asyncContainer: value };
            }
            // if its a function that must be called (lazily executing function)
            else if (typeof value === 'function') {
                // @ts-ignore
                acc[key] = { asyncContainer: value };
            }
            // if its a delegate module, skip it
            else if (typeof value === 'string' && value.startsWith('internal ')) {
                const [request, query] = value.replace('internal ', '').split('?');
                if (query) {
                    const remoteSyntax = new URLSearchParams(query).get('remote');
                    if (remoteSyntax) {
                        const [url, global] = extractUrlAndGlobal(remoteSyntax);
                        acc[key] = { global, url };
                    }
                }
            }
            // if its just a string (global@url)
            else if (typeof value === 'string') {
                const [url, global] = extractUrlAndGlobal(value);
                acc[key] = { global, url };
            }
            // we dont know or currently support this type
            else {
                //@ts-ignore
                console.warn('remotes process', process.env.REMOTES);
                throw new Error(`[mf] Invalid value received for runtime_remote "${key}"`);
            }
            return acc;
        }, {});
    }
    catch (err) {
        console.warn('Unable to retrieve runtime remotes: ', err);
    }
    return {};
};

const importDelegatedModule = (keyOrRuntimeRemoteItem) => __awaiter(void 0, void 0, void 0, function* () {
    // @ts-ignore
    return loadScript(keyOrRuntimeRemoteItem)
        .then((asyncContainer) => {
        return asyncContainer;
    })
        .then((asyncContainer) => {
        // most of this is only needed because of legacy promise based implementation
        // can remove proxies once we remove promise based implementations
        if (typeof window === 'undefined') {
            if (!Object.hasOwnProperty.call(keyOrRuntimeRemoteItem, 'globalThis')) {
                return asyncContainer;
            }
            // return asyncContainer;
            //TODO: need to solve chunk flushing with delegated modules
            return {
                get: function (arg) {
                    //@ts-ignore
                    return asyncContainer.get(arg).then((f) => {
                        const m = f();
                        const result = {
                            __esModule: m.__esModule,
                        };
                        for (const prop in m) {
                            if (typeof m[prop] === 'function') {
                                Object.defineProperty(result, prop, {
                                    get: function () {
                                        return function () {
                                            //@ts-ignore
                                            if (globalThis.usedChunks) {
                                                //@ts-ignore
                                                globalThis.usedChunks.add(
                                                //@ts-ignore
                                                `${keyOrRuntimeRemoteItem.global}->${arg}`);
                                            }
                                            //eslint-disable-next-line prefer-rest-params
                                            return m[prop](...arguments);
                                        };
                                    },
                                    enumerable: true,
                                });
                            }
                            else {
                                Object.defineProperty(result, prop, {
                                    get: () => {
                                        //@ts-ignore
                                        if (globalThis.usedChunks) {
                                            //@ts-ignore
                                            globalThis.usedChunks.add(
                                            //@ts-ignore
                                            `${keyOrRuntimeRemoteItem.global}->${arg}`);
                                        }
                                        return m[prop];
                                    },
                                    enumerable: true,
                                });
                            }
                        }
                        if (m.then) {
                            return Promise.resolve(() => result);
                        }
                        return () => result;
                    });
                },
                init: asyncContainer.init,
            };
        }
        else {
            return asyncContainer;
        }
    });
});

export { Logger, createRuntimeVariables, extractUrlAndGlobal, getContainer, getModule, getRuntimeRemotes, importDelegatedModule, importRemote, injectScript, isObjectEmpty, loadScript };
